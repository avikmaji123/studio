/**
 * # Core Philosophy
 * This ruleset enforces a strict, user-centric security model. Data is primarily segregated into user-owned documents and publicly readable, admin-managed collections. The default posture is to deny access unless explicitly granted, ensuring that users can only interact with their own information.
 *
 * # Data Structure
 * The data is organized hierarchically. Core user data and related private subcollections (like enrollments, certificates, and payment transactions) are nested under `/users/{userId}`. This path-based structure simplifies ownership rules. Publicly-accessible data, such as the course catalog, is stored in top-level collections like `/courses` and `/lessons`. Administrative and system logs are also segregated into their own top-level collections (`/adminActionLogs`, `/apiLogs`, `/logs`) to isolate them from user and application data. A new top-level `/certificates` collection holds public verification data.
 *
 * # Key Security Decisions
 * - User Isolation: A user can only access documents within their own `/users/{userId}` data tree. Listing or reading other users' profiles is strictly forbidden, except for admins.
 * - Admin Privileges: A role-based access control (RBAC) system is implemented for administrative tasks. Users with `role == 'admin'` in their user profile can manage global collections.
 * - Public vs. Private: Data is structurally segregated. Public content (courses, certificate verification records) is in top-level collections with specific access rules. Private, user-specific data (enrollments, private certificate records) is in user subcollections, protected by ownership rules.
 * - Backend-Only Collections: Collections like `/apiLogs`, `/adminActionLogs`, and `/logs` are considered backend-managed. Client-side writes are completely disabled to prevent tampering, and reads are restricted to administrators. This ensures the integrity of the audit trail.
 * - Certificate Security: A public, top-level `/certificates/{certificateCode}` collection allows anyone to `get` a certificate record if they know the unique, non-guessable code. `list` and `write` are forbidden for clients to protect privacy and prevent forgery.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isAdmin() {
      // This function is safe to use as long as it's not used in rules for /users/{userId}
      // which would cause a circular dependency.
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    function isExistingAdmin() {
        return isAdmin() && resource != null;
    }

    // --------------------------------
    // User Collections
    // --------------------------------

    match /users/{userId} {
      // RECURSION FIX: An owner can get their own doc. An admin can get any doc.
      // We check the admin's role directly on their own user doc to avoid circular calls to isAdmin().
      allow get: if isOwner(userId) || (isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');
      
      allow list: if isAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    match /users/{userId}/enrollments/{enrollmentId} {
      allow get, list: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages a user's private references to their certificates. This is for populating the user's dashboard.
     *   Public verification is handled by the top-level `/certificates` collection. Admins have full control here.
     * @path /users/{userId}/certificates/{certificateId}
     */
    match /users/{userId}/certificates/{certificateId} {
      allow read, write: if isOwner(userId) || isAdmin();
    }

    match /users/{userId}/paymentTransactions/{transactionId} {
      allow get, list: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    match /users/{userId}/affiliateCommissions/{affiliateCommissionId} {
      allow get, list: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId) && request.resource.data.affiliateId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.affiliateId == resource.data.affiliateId;
      allow delete: if isExistingOwner(userId);
    }

    match /users/{userId}/apiKeys/{apiKeyId} {
      allow get, list: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }
    
    // --------------------------------
    // Collection Group Rules
    // --------------------------------

    match /{path=**}/paymentTransactions/{transactionId} {
      allow get, list: if isAdmin();
    }

    // --------------------------------
    // Public & Admin Collections
    // --------------------------------

    match /courses/{courseId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }
    
    match /coupons/{couponId} {
      // Use email check for list to avoid using get() in a query rule.
      allow list: if request.auth.token.email == 'avik911@courseverse.admin';
      // Get and write can still use the more robust role-based check.
      allow get, create, update, delete: if isAdmin();
    }

    match /lessons/{lessonId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Publicly-verifiable certificate records. The document ID is the unique code.
     *   This collection is read-only for the public to allow verification.
     *   Writes should only be performed by a trusted backend process or admin.
     * @path /certificates/{certificateCode}
     * @allow (get) Any user (authenticated or not) can fetch a specific certificate if they know its code.
     * @deny (list) Listing all certificates is forbidden to protect privacy.
     * @allow (create, update, delete) Admins can manage these records.
     */
    match /certificates/{certificateCode} {
        allow get: if true;
        allow list: if isAdmin();
        allow write: if isAdmin();
    }

    match /apiLogs/{apiLogId} {
      allow get, list: if isAdmin();
      allow create, update, delete: if false;
    }

    match /adminActionLogs/{adminActionLogId} {
      allow get, list: if isAdmin();
      allow create, update, delete: if false;
    }

    match /logs/{logId} {
        allow get, list: if isAdmin();
        allow create: if request.resource.data.timestamp == request.time;
        allow update, delete: if false;
    }
    
    match /settings/{settingsId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    match /reviews/{reviewId} {
      // Admins can do anything.
      allow write: if isAdmin();

      // Logged-in users can create reviews for themselves.
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      
      // Admins can read any review. Logged-in users can read their own reviews.
      allow read: if isAdmin() || (isSignedIn() && resource.data.userId == request.auth.uid);
    }
  }
}
